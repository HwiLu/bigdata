# 线程安全性
## 线程带来的风险
- 安全性问题  
多线程由于共享相同的内存地址空间，在并发运行时，可能会访问和修改其他线程正在使用的变量。
- 活跃性问题   
活跃性关注于“某件正确的事情最终会发生”。在多线程中，可能因为死锁，饥饿等问题，导致某线程永久等待资源而出现活跃性问题。
- 性能问题   
线程调度器临时挂起活跃线程转而运行其他线程，带来频繁的上下文切换操作，使 CPU 将更多时间花费在线程调度而不是线程运行上；另外线程共享数据时，必须使用同步机制，而这些机制往往会抑制某些编译器的优化，使用内存缓存区的数据无效，以及增加共享内存总线的同步流量。

## 线程安全性
要编写线程安全的代码，其核心在于对 *状态* 访问操作进行管理，特别是对 *共享* 状态和 *可变* 状态的访问。对象的状态是指存储在状态变量（如实例和静态域）中的数据。
对象的状态可能包括其他依赖对象的域。共享意味着变量可由多个线程同时访问，可变意味着变量的值在其生命周期内可发生变化。

多个线程访问某个状态变量且至少有一个线程执行写入操作时，必须使用同步机制来保证线程安全。Java 同步机制主要是指关键字 `synchronized`，其提供了独占的加锁方式。同步机制还包括 `volatile` 变量，显式锁及原子变量。

### 什么是线程安全性
在线程安全性的定义中，最核心的概念就是正确性。正确性的含义是某个类的行为与规范完全一样。良好的规范通常会定义各种不变性条件来约束对象的状态，以及定义各种后验条件来描述对象操作的结果。在对“正确性”给出一个较为清晰的定义后，就可以来定义线程安全性：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

无状态对象(既不包含任何域，也不包含对任何其他域的引用)一定是线程安全的。

### 原子性
竞态条件：在并发编程中，由于不恰当的执行顺序而出现不正确结果的情况。最常见的竞态条件类型是“先检查后执行”：首先观察到某个条件为真，然后根据这个观察结果采用相应的动作，但事实上，**在观察到这个结果和采用相应动作之间，观察结果可能变得无效，从而导致各种问题**。

使用“先检查后执行”的一种常见情况就是延迟初始化。延迟初始化的目的是将对象初始化操作推迟到实际使用时才进行，同时确保只被初始化一次。常见的一种延迟初始化场景是懒汉式线程不安全的单例模式写法，很多教科书上也是这样教我们的，遗憾的是这种写法是错误的：
```
@NotThreadSafe
public class Singleton {
    private static Singleton instance;

    public static Singleton getInstance() {
	if (instance == null) {
	    instance = new Singleton();
	}
	return instance;
    }
}
```

要避免竞态条件，就必须在某个线程修改变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改变量。为了确保线程安全性，“先检查后执行”（如延迟初始化）和“读取-修改-写入”（如递增运算）等操作必须是原子的。将“先检查后执行”和“读取-修改-写入”等操作统称为复合操作：即包含一组必须以原子方式执行的操作。

### 加锁机制
上面说了复合操作需要以原子方式进行操作，那该怎么支持原子性呢？

Java 提供了一种内置的锁机制来支持原子性：同步代码块(Synchronized Block)。以关键字 `synchronized` 来修饰的方法就是一种横跨整个方法全的同步代码块，其中该同步代码块的锁就是方法调用所在的对象，静态的 `synchronized` 方法以 Class 对象作为锁。

```
synchronized (lock) {
// 访问或修改由锁保护的共享状态。
}
```
线程在进入同步代码块之前会自动获得锁，在退出同步代码块时自动释放锁。无论是正常退出还是抛出异常退出代码块，获得锁的唯一途径就是进入这个由锁保护的同步代码块。

需要注意的是，虽然 `synchronized` 方法可以确保每个操作的原子性，但如果将多个原子操作合并为一个复合操作，还是需要额外的加锁机制。

一种常见的约定是，将所有会被多线程访问的可变状态都封闭在对象内部，通过对象的内置锁对所有访问可变状态的代码进行同步，从而使该对象上不会发生并发访问。对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。
### 重入
疑问：书中的代码为什么父类会拿2次锁？


### 活跃性和性能
对在单个变量上实现原子操作来说，原子变量是很有用的，但若已经使用了 `synchronized` 关键字的代码块来构造原子操作，该操作中可不必使用原子变量，因为同时使用两种不同的同步机制不住会带来混乱，也不会在性能和安全性上带来任何好处。

当执行时候较长的计算或可能无法快速完成的操作时（如网络I/O或控制台I/O），一定不要持有锁。

### 小结
上述主要介绍了线程安全性方面的内容，介绍了什么是线程安全性，出现安全性问题一般是未能保证复合操作的原子性导致，解决方式是在保证活跃性和性能的前提下对复合操作加锁。


