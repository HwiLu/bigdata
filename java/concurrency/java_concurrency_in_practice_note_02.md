# 对象的共享
上文介绍了同步代码块可以确保以原子的形式进行操作，但同步代码块除了实现原子性外，还有另外一个重要的方面：内存可见性（Memory Visibility）。我们不止希望某个线程在修改对象状态时要防止另外一个线程同时使用该对象状态，而且希望当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。如果没有同步，那么这种情况就无法实现。

## 可见性
为了保证多个线程之间对内存写入操作的可见性，必须使用同步机制。

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，这种安全性保证被称为最低安全性。最低安全性适用于绝大多数变量，但有一种例外，非 `volatile` 类型的 64 位数据变量（即 `long` 和 `double`）。Java 内存模型要求，变量的读取和写入操作都必须是原子操作，但对于非 `volatile` 类型的 `long` 和 `double` 变量，JVM 允许将 64 位的读写操作分解为两个 32 位的操作，若此时对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高 32 位和另一个值的低 32 位。因此，在多线程中使用共享且可变的 `long` 和 `double` 等类型的变量也是不安全的，除非使用关键字 `volatile` 来声明它们，或者用锁保护起来。

**为了确保所有线程都能看到共享变量的最新值，所有针对同一变量进行的读写操作都必须在同一个锁上同步**。一个线程在未持有正确锁的情况下读取的变量仍可能是一个失效值。

### volatile 变量
Java 提供了一种稍弱的同步机制，即 `volatile` 变量。当变量声明为 `volatile` 类型后，该变量就有两层语义：
- `volatile` 变量不会被缓存在寄存器或对其他处理器不可见的地方，因此**读取 volatile 类型的变量时总会返回最新写入的值**。
- *编译器* 和 *运行时* 会注意到这个变量是共享的，因此**不会将变量上的操作与其他内存操作一起进行指令重排**。

`volatile` 变量是一种比 `synchronized` 更轻量级的同步机制：在访问 `volatile` 变量时不会执行加锁操作，因此也就不会使执行线程阻塞。不过不建议过度依赖 `volatile` 变量提供的可见性，因为使用 `volatile` 的代码一般比使用锁的代码更脆弱，也更难以理解。`volatile` 变量的正确使用方式包括：
- 确保它们自身状态的可见性；
- 确保它们所引用对象的状态的可见性；
- 标识一些重要的程序生命周期事件的发生（如初始化或关闭）。
如下代码是 `volatile` 变量的一种典型应用：检查某个标记以判断是否退出循环：
```
volatile boolean asleep;
...
    while (!asleep)
        countSomeSheep();
```

当且仅当满足以下所有条件时，才应该使用 `volatile` 变量：
- 对变量的写入操作不依赖变量的当前值，或能确保只有单个线程更新变量的值。
- 该变量不会与其他变量一起纳入不变性条件中。
- 在访问变量时不需要加锁。

**加锁机制既可以确保可见性又可以确保原子性，而 `volatile` 变量只能确保可见性**，即volatile 的语义不足以保证复合操作的原子性。

## 发布与逸出
[参考源码](http://jcip.net/listings/ThisEscape.java)：
```
public class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
            }
        });
    }

    void doSomething(Event e) {
    }


    interface EventSource {
        void registerListener(EventListener e);
    }

    interface EventListener {
        void onEvent(Event e);
    }

    interface Event {
    }
}
```

问题：this是如何逸出的？

## 线程封闭
当访问共享的可变数据时，通常需要使用同步，一种避免使用同步的方式就是不共享数据，如果单线程内访问数据，就不需要同步，这种技术被称为线程封闭（Thread Confinement）。当对象被封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。Swing 大量使用了线程封闭技术，Swing 应用程序的许多并发错误都是由于错误的在另一个线程中使用了这些被封闭的对象。

不过需要注意的是，Java 语言无法强制将对象封闭在某个线程中，线程封闭是程序设计中的一个考虑因素，必须在程序中实现。

### Ad-hoc 线程封闭
Ad-hoc 线程封闭是指维护线程封闭性的职责完全由程序实现来承担。Ad-hoc 线程封闭非常脆弱，因为没有任何语言特性，能将对象封闭到目标线程上，所以在程序中尽量少使用该技术。

在 volatile 变量上存在一种特殊的线程封闭，只要能确保只有单个线程对共享的 volatile 变量执行写入操作，那么就可以安全的在这些共享的 volatile 变量上执行 “读取-修改-写入” 操作。此时相当于将修改操作封闭在单个线程中以防止发生竞态条件。

### 栈封闭
栈封闭是线程封闭的一种特例，**在栈封闭中，只能通过局部变量才能访问对象**。局部变量的固有属性之一就是封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。

由于任何方法都无法获得对基本类型的引用，所以基本类型的局部变量始终封闭在线程内。而对于对象引用而言，需要程序不对外返回对象引用。

### ThreadLocal 类
维持线程封闭性的一种更规范方法是使用 ThreadLocal，该类提供了 `get` 和 `set` 等访问接口和方法，这些方法为每个使用该变量的线程都保存一份独立的副本，因此 `get` 总是返回由当前执行线程在调用 `set` 时设置的最新值。

当某个频繁执行的操作需要一个临时对象，同时又希望避免在每次执行时都重新分配该临时对象，就可以使用这项技术。

## 不变性
前面说的原子性和可见性相关的问题，都与多线程试图同时访问一个可变的状态相关。如果对象的状态不会改变，那么这些问题与复杂性也就消失了。如果某个对象在被创建后其状态就不能被修改，那么这个状态就被称为不可变对象。不可变对象一定是线程安全的。

不可变并不等同于将对象中所有的域都声明为 `final` 类型，因为 `final` 类型的域可以保存对可变对象的引用。当满足如下条件时，对象才是不可变的：
- 对象创建以后其状态就不能修改。
- 对象的所有域都是 `final` 类型。
- 在对象的创建期间，this 引用没逸出。

##  安全发布
对于不可变对象，任何线程都可以在不需要额外同步的情况下安全的访问不可变对象，即使在发布这些对象时没有使用同步。

对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。要安全的发布一个对象，对象的引用及对象的状态必须同时对其他线程可见。一个正确构造的对象可通过以下方式来安全的发布：
- 在静态初始化函数中初始化一个对象引用。
- 将对象的引用保存到 `volatile` 类型的域或 `AtomicReferance` 对象中。
- 将对象的引用保存到某个正确构造对象的 `final` 类型域中。
- 将对象的引用保存到一个由锁保所的域中。

在并发程序中使用和共享对象时，可以使用一些实用的策略，如：
- 线程封闭。线程封闭的对象只能由一个线程拥有，对象封闭在该线程中，并且只能由这个线程修改。
- 只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。
- 线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。
- 保护对象。被保护的对象只能通过持有特定的锁来访问。

## 小结
本章主要介绍了对象共享方面的内容，主要包括可见性，线程封闭技术，不变性和安全发布等几方面内容。
其中可见性主要介绍了如下方面内容：
- 可见性的概念：某个线程修改对象状态后，其他线程能看到发生的状态变化。
- 如何保证可见性：同步代码块不仅保证了原子性，也保证了可见性；`volatile` 除了禁止指令重排，也保证了可见性。

接着是几种在共享变量时避免使用同步的方法：其一是线程封闭；其二是不可变对象。
而线程封闭主要介绍了如下方面：
- 为啥需要有线程封闭？啥是线程封闭？
当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据，因此若在单线程内访问数据的话，就不需要同步。这种技术被称为线程封闭。
- 线程封闭的 3 种实现方式： 
  - Ad-hoc 线程封闭。即维护线程封闭性的职责完全由程序来承担。该方式是非常脆弱，尽量少用。
  - 栈封闭。即线程内部使用局部变量，其他线程无法访问这个栈。对于基本类型的局部变量，不会破坏栈封闭性。对于对象而言，需保证对象引用不会逸出。
  - ThreadLoal 类。该类为每个使用变量的线程都存有一份副本，使得 get 总是返回该线程 set 的值。

避免同步的另一种方法是使用不可变对象，因为不可变对象一定是线程安全的。不可变对象需满足的条件：状态不可修改，所有域都是 `final` 类型，正确的构造过程。

综上，想要安全的共享数据，可使用线程封闭技术和不可变对象避免同步，或对于可变对象，发布和使用该对象的线程都使用同步。
