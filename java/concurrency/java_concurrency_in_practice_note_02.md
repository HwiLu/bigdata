# 对象的共享
上文介绍了同步代码块可以确保以原子的形式进行操作，但同步代码块除了实现原子性外，还有另外一个重要的方面：内存可见性（Memory Visibility）。我们不止希望某个线程在修改对象状态时要防止另外一个线程同时使用该对象状态，而且希望当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。如果没有同步，那么这种情况就无法实现。

## 可见性
为了保证多个线程之间对内存写入操作的可见性，必须使用同步机制。

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，这种安全性保证被称为最低安全性。最低安全性适用于绝大多数变量，但有一种例外，非 `volatile` 类型的 64 位数据变量（即 `long` 和 `double`）。Java 内存模型要求，变量的读取和写入操作都必须是原子操作，但对于非 `volatile` 类型的 `long` 和 `double` 变量，JVM 允许将 64 位的读写操作分解为两个 32 位的操作，若此时对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高 32 位和另一个值的低 32 位。因此，在多线程中使用共享且可变的 `long` 和 `double` 等类型的变量也是不安全的，除非使用关键字 `volatile` 来声明它们，或者用锁保护起来。

**为了确保所有线程都能看到共享变量的最新值，所有针对同一变量进行的读写操作都必须在同一个锁上同步**。一个线程在未持有正确锁的情况下读取的变量仍可能是一个失效值。

### volatile 变量
Java 提供了一种稍弱的同步机制，即 `volatile` 变量。当变量声明为 `volatile` 类型后，该变量就有两层语义：
- `volatile` 变量不会被缓存在寄存器或对其他处理器不可见的地方，因此**读取 volatile 类型的变量时总会返回最新写入的值**。
- *编译器* 和 *运行时* 会注意到这个变量是共享的，因此**不会将变量上的操作与其他内存操作一起进行指令重排**。

`volatile` 变量是一种比 `synchronized` 更轻量级的同步机制：在访问 `volatile` 变量时不会执行加锁操作，因此也就不会使执行线程阻塞。不过不建议过度依赖 `volatile` 变量提供的可见性，因为使用 `volatile` 的代码一般比使用锁的代码更脆弱，也更难以理解。`volatile` 变量的正确使用方式包括：
- 确保它们自身状态的可见性；
- 确保它们所引用对象的状态的可见性；
- 标识一些重要的程序生命周期事件的发生（如初始化或关闭）。
如下代码是 `volatile` 变量的一种典型应用：检查某个标记以判断是否退出循环：
```
volatile boolean asleep;
...
    while (!asleep)
        countSomeSheep();
```

当且仅当满足以下所有条件时，才应该使用 `volatile` 变量：
- 对变量的写入操作不依赖变量的当前值，或能确保只有单个线程更新变量的值。
- 该变量不会与其他变量一起纳入不变性条件中。
- 在访问变量时不需要加锁。



**加锁机制既可以确保可见性又可以确保原子性，而 `volatile` 变量只能确保可见性**，即volatile 的语义不足以保证复合操作的原子性。

## 发布与逸出
[参考源码](http://jcip.net/listings/ThisEscape.java)：
```
public class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
            }
        });
    }

    void doSomething(Event e) {
    }


    interface EventSource {
        void registerListener(EventListener e);
    }

    interface EventListener {
        void onEvent(Event e);
    }

    interface Event {
    }
}
```

## 线程封闭
当访问共享的可变数据时，通常需要使用同步，一种避免使用同步的方式就是不共享数据，如果单线程内访问数据，就不需要同步，这种技术被称为线程封闭（Thread Confinement）。当对象被封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。Swing 大量使用了线程封闭技术，Swing 应用程序的许多并发错误都是由于错误的在另一个线程中使用了这些被封闭的对象。

不过需要注意的是，Java 语言无法强制将对象封闭在某个线程中，线程封闭是程序设计中的一个考虑因素，必须在程序中实现。

### Ad-hoc 线程封闭
Ad-hoc 线程封闭是指维护线程封闭性的职责完全由程序实现来承担。Ad-hoc 线程封闭非常脆弱，因为没有任何语言特性，能将对象封闭到目标线程上，所以在程序中尽量少使用该技术。

在 volatile 变量上存在一种特殊的线程封闭，只要能确保只有单个线程对共享的 volatile 变量执行写入操作，那么就可以安全的在这些共享的 volatile 变量上执行 “读取-修改-写入” 操作。此时相当于将修改操作封闭在单个线程中以防止发生竞态条件。

### 栈封闭
栈封闭是线程封闭的一种特例，**在栈封闭中，只能通过局部变量才能访问对象**。局部变量的固有属性之一就是封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。

由于任何方法都无法获得对基本类型的引用，所以基本类型的局部变量始终封闭在线程内。而对于对象引用而言，需要程序不对外返回对象引用。

### ThreadLocal 类
维持线程封闭性的一种更规范方法是使用 ThreadLocal，该类提供了 `get` 和 `set` 等访问接口和方法，这些方法为每个使用该变量的线程都保存一份独立的副本，因此 `get` 总是返回由当前执行线程在调用 `set` 时设置的最新值。
