# 对象的共享
上文介绍了同步代码块可以确保以原子的形式进行操作，但同步代码块除了实现原子性外，还有另外一个重要的方面：内存可见性（Memory Visibility）。我们不止希望某个线程在修改对象状态时要防止另外一个线程同时使用该对象状态，而且希望当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。如果没有同步，那么这种情况就无法实现。

## 可见性
为了保证多个线程之间对内存写入操作的可见性，必须使用同步机制。

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，这种安全性保证被称为最低安全性。最低安全性适用于绝大多数变量，但有一种例外，非 `volatile` 类型的 64 位数据变量（即 `long` 和 `double`）。Java 内存模型要求，变量的读取和写入操作都必须是原子操作，但对于非 `volatile` 类型的 `long` 和 `double` 变量，JVM 允许将 64 位的读写操作分解为两个 32 位的操作，若此时对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高 32 位和另一个值的低 32 位。因此，在多线程中使用共享且可变的 `long` 和 `double` 等类型的变量也是不安全的，除非使用关键字 `volatile` 来声明它们，或者用锁保护起来。

**为了确保所有线程都能看到共享变量的最新值，所有针对同一变量进行的读写操作都必须在同一个锁上同步**。一个线程在未持有正确锁的情况下读取的变量仍可能是一个失效值。

### volatile 变量
Java 提供了一种稍弱的同步机制，即 `volatile` 变量。当变量声明为 `volatile` 类型后，该变量就有两层语义：
- `volatile` 变量不会被缓存在寄存器或对其他处理器不可见的地方，因此**读取 volatile 类型的变量时总会返回最新写入的值**。
- *编译器* 和 *运行时* 会注意到这个变量是共享的，因此**不会将变量上的操作与其他内存操作一起进行指令重排**。

`volatile` 变量是一种比 `synchronized` 更轻量级的同步机制：在访问 `volatile` 变量时不会执行加锁操作，因此也就不会使执行线程阻塞。不过不建议过度依赖 `volatile` 变量提供的可见性，因为使用 `volatile` 的代码一般比使用锁的代码更脆弱，也更难以理解。`volatile` 变量的正确使用方式包括：
- 确保它们自身状态的可见性；
- 确保它们所引用对象的状态的可见性；
- 标识一些重要的程序生命周期事件的发生（如初始化或关闭）。
如下代码是 `volatile` 变量的一种典型应用：检查某个标记以判断是否退出循环：
```
volatile boolean asleep;
...
    while (!asleep)
        countSomeSheep();
```

当且仅当满足以下所有条件时，才应该使用 `volatile` 变量：
- 对变量的写入操作不依赖变量的当前值，或能确保只有单个线程更新变量的值。
- 该变量不会与其他变量一起纳入不变性条件中。
- 在访问变量时不需要加锁。



**加锁机制既可以确保可见性又可以确保原子性，而 `volatile` 变量只能确保可见性**，即volatile 的语义不足以保证复合操作的原子性。


