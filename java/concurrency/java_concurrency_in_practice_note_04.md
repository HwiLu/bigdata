# 基础构建模块

上一章介绍了如何基于已有的类构造线程安全类，介绍了构造线程安全类的方法：维护所有变量的不变性条件并建立对象的并发访问策略。并具体提到了几种方法：针对非线程安全类，可以以 Java 监视器模式实现实例封闭的方法，来构造线程安全类；对于已是线程安全的类，若其变量均是独立且安全的，则构造成新的对象也是线程安全的，若变量非独立，则需加锁来维护不变性条件。对于 Java 中的基础类，提到了四种方法来确保安全性：直接修改原始类；扩展原始类；客户端加锁；组合（额外再加锁）。这一章就具体深入看看 Java 提供了哪些并发构建模块。

## 同步容器类
同步容器类都是线程安全的，不过容器上的复合操作还是需要额外的客户端加锁来保证线程安全。有时开发人员并不希望在复合操作期间加锁，因为如果容器规模很大，或在每个容器的元素上执行操作的时间过长，那么其他线程将会长时间等待，此时可能造成死锁或饥饿等风险。长时间对容器加锁会降低程序的可伸缩性。

如果不希望在复合操作期间对容器加锁，那么一种代替方法就是“克隆”容器，并在副本上进行复合操作，这样副本被封闭在线程中，就避免了线程非安全问题，不过需要注意的是，在克隆过程中仍然需要对容器加锁，此时仍可能存在显著的性能开销。

##　并发容器

### ConcurrentHashMap
使用分段锁（Lock Striping）提高性能，ConcurrentHashMap 返回的迭代器具有弱一致性（Weakly Consistent）。但对于一些需要在整个 Map 上进行计算的方法，例如 size 和  isEmpty，这些方法的语义被略微削弱了以反映容器的并发特性。 size 返回的结果在计算时可能已经过期了，实际上其只是一个估计值，不过由于这些方法在并发环境上的用处很小，因为它们的返回值总在不断变化。因此这些操作的需求被弱化了，以换取对其他更重要操作的性能优化。

由于 ConcurrentHashMap 不能被加锁来执行独占访问，因此无法对 ConcurrentHashMap 使用上一章所说的客户端加锁来创建新的原子操作。若需要在现在的同步 Map 中添加这样的功能，很可能意味着应该考虑使用 ConcurrentMap 了。

## 同步工具类
同步工具类可以是任何一个对象，只要它根据自身的状态来协调线程的控制流。同步工具类主要包括阻塞队列，信号量（semaphore），栅栏（Barrier）以及闭锁（latch）及平台类库中提供的其他同步工具类，如果这些类还无法满足需求，可根据后面介绍的机制来创建自己的同步工具类。

同步工具类都包含一些特定的结构化属性：**它们封闭了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另外一些方法用于高效地等待同步工具类进入到预期状态**。

### 闭锁（latch）
闭锁相当于一扇门：在闭锁到达结束状态前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门将永远保持打开状态。闭锁可以确保某些活动直到其他活动都完成后才继续进行，如：
- 确保某个计算在其需要的所有多资源都被初始化后才能继续执行。二元闭锁（包括两个状态）可以用来表示“资源 R 已被初始化”，而所有需要 R 的操作都必须先在这个闭锁上等待。
- 确保某个服务在其依赖的所有其他服务都已经启动之后才启动。当启动服务 S 时，将首先在 S 依赖的其他服务的闭锁上等待，在所有依赖的服务都启动后会释放闭锁 S，这样其他依赖 S 的服务才能继续执行。
- 等待某个操作的所有参与者都就绪再继续执行。当所有参与者都准备就绪时，闭锁将到达结束状态。

CountDonwLatch 是一种灵活的闭锁实例，它可以使一个或多个线程等待一组事件发生。更多参考[官方API](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html)。

### FutureTask
FutureTask 也可用做闭锁，Future.get 的行为取决于任务的状态。如果任务已完成，那么 get 会立即返回结果，否则 get 将阻塞直到任务进入完成状态，然后返回结果或抛出异常。FutureTask 表示的计算是通过 Callable 来实现的。Callable 表示的任务可以抛出异常，并且任何代码都可能抛出一个 Error。无论任务代码抛出什么异常，都会封闭到一个 ExecutionException 中，并在 Future.get 中重新抛出。Callable 抛出的 ExecutionException ，可能是以下三种情况之一：Callable 抛出的受检测的异常，RuntimeException 以及 Error。

### 信号量
计数信号量（Counting Semaphore）用来控制同时访问某个特定资源的操作数量，或同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或对容器施加边界。

Semaphore 中管理着一组虚拟的许可（permit），许可的初始数量可通过构造函数来指定。在执行操作时可以首先获得许可（只要还有剩余的许可），并在使用以后释放许可。如果没有许可，那么 acquire 将阻塞直到有许可（或直到被中断或操作超时）。release 方法将返回一个许可给信号量。计算信号量的一种简化形式是二值信号量，即初始值为 1 的 Semaphore。

Semaphore 可用于实现资源池，例如数据库连接池。我们可以构造一个固定长度的资源池，当池为空时，请求资源将会阻塞，当池非空时解决阻塞。同样，可使用 Semaphore 将任何一种容器变成有界阻塞容器，此时容器容量的最大值即信号量的计数值，容器的 add 操作在向底层容器添加元素之前，首先需要获取一个许可。同样，remove 操作会释放一个许可。

### 栅栏（Barrier）
前面已经看到通过 latch 来启动一组相关操作，或等待一组相关的操作结束。latch 是一次性对象，一旦进入终止状态，就不能被重置。栅栏类似于 latch，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。

CyclicBarrier 可以使一定数量的参与方反复地在栅栏位置汇集，它在并行迭代算中非常有用：当线程到达栅栏位置时将调用 await 方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达了栅栏位置，那么栅栏将打开，此时所有线程都被释放，而栅栏将被重置以便下次使用。如果对 await 的调用超时，或者 await 阻塞的线程被中断，那么栅栏就被认为是打破了，所有阻塞的 await 调用都将终止并抛出 BrokenBarrierException。如果成功通过栅栏，那么 await 将为每个线程返回一个唯一索引，可利用这些索引来“选举”产生一个领导线程，并在下一次迭代中由该领导线程执行一些特殊工作。

在模拟程序中通常需要使用栅栏，如某个步骤的并行计算需等到该步骤中的所有计算都执行完毕才能进入到下一个步骤。

另一种形式的栅栏是 Exchanger，它是一种两方栅栏，各方在栅栏位置上交换数据，当两方执行不对称的操作时，Exchanger 会非常有用，例如当一个线程向缓冲区写入数据，另外一个线程从缓冲区读取数据。这些线程可以使用 Exchanger 来汇合，并将满的缓冲区与空的缓冲区置换。

## 构建高效且可伸缩的结果缓存
这里分析了一个以构建可伸缩的缓存为目标的例子，具体可以参见书中叙述，代码可参考 [Memoizer1.java](http://jcip.net/listings/Memoizer1.java) 等。其中有几种值得学习的，为避免多个线程同时计算某个值，使用了 FutureTask。而由于复合操作（“若没有则添加”）在底层 Map 上执行，使用了 ConcurrentMap 中的原子方法 `putIfAbsent` 。不过当缓存的是 Future 而不是值时，将导致缓存污染问题：如果某个计算被取消或失败。那么在计算这个结果时将指明计算过程被取消或失败，此时需要将把 Future 从缓存中移除。

## 小结
上一章介绍了构造线程安全类的一些技术，比如 Java 监视器模式组合线程不安全的类等，本章则介绍了 Java 平台类中的基础容器类，主要包括如下：
- 同步容器类，如 Vector 和 Hashtble，不过对于复合操作还是需要额外的客户端加锁来保证线程安全性，此时对于大容器，加锁可能会带来性能问题，一种替代方法是“克隆”容器，在副本上进行操作，由于副本被封闭在线程内，因此其他线程不会在迭代期间对其进行修改，需注意的是，在克隆容器时会存在显著的性能开销。
- 并发容器类，主要介绍了 ConcurrentHashMap 的相关内容，如使用分段锁提高并发性能。不过由此削弱了部分在整个 Map 上进行计算的方法的语义，如 size 和 isEmpty 等，其返回的值是只是一个估计值。如果需要额外的 ConcurrentHashMap 不能满足的原子操作，则需要实现 ConcurrentMap 接口。
- 同步工具类
  - 闭锁：确保某些活动直到其他活动都完成后才执行。一旦达到完成状态，将无法再变更状态。典型应用是 CountDownLatch。
  - FutureTask：FutureTask 也可用做闭锁。Future.get 的行为取决于任务状态，如果任务完成，那么 get 会立即返回结果，否则 get 将阻塞直到任务进入完成状态，然后返回结果或抛出异常。
  - 信号量：用来控制同时访问某个特定资源的操作数量，或同时执行某个指定操作的数量。信号量可用于实现资源池或将任何一种容器变为有界阻塞容器。
  - 栅栏：类似于闭锁，能阻塞一组线程直到某个事件发生。其与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行，闭锁用于等待事件，而栅栏用于等待其他线程。介绍了 CyclicBarrier 和 Exchanger 这两种栅栏。

另外还讨论了阻塞队列 BlockingQueue 的使用场景之一-- 生产者消费者模式和如何构造高效且可伸缩的缓存，此不赘述。

## 第一部分小结
这里对前面几章做个小结：
- 可变状态至关重要：所有并发问题都可以归结为如何协调对并发状态的访问。
- 尽量将域声明为 `final` 类型，除非需要它们是可变的。
- 不可变对象一定是线程安全的。
- 封闭有助于管理复杂性。
- 当保护同一个不变性条件中的所有变量时，要使用同一个锁。
- 执行复合操作期间，要持有锁。
- 在设计过程中考虑线程安全，或在文档中明确地指出它不是线程安全的。

